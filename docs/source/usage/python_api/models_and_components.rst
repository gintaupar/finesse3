.. include:: /defs.hrst

.. _models_components_python:

Models and Components
=====================

Using the python interface to construct your |Finesse| model can be more verbose than
using :ref:`syntax`, but gives you access to syntax highlighting and autocompletion,
especially when using a modern IDE like VSCode or PyCharm. It also offers the
most feature rich API to interact with |Finesse| models. All features are
supported in Python API, whereas only a subset are support in KatScript.

.. note::

    If you want to know how to map a KatScript command to a Python method or class you
    can inspect the :meth:`.finesse.script.spec.KatSpec._register_constructs` method in
    :source:`script/spec.py` which sets up the various links between KatScript and
    Python API.

Adding components to a model
============================

All the :ref:`KatScript components<elements>`, have a Python class associated in either
the :mod:`finesse.components` or the :mod:`.finesse.detectors` module. Documentation can
also be accessed using the python :func:`help` method

.. jupyter-execute::

    from finesse import Model
    from finesse.components import Laser, Mirror, Space, Beamsplitter
    from finesse.detectors import PowerDetector

    # help(Laser) # would print the help for the Laser

Adding components is done using :meth:`.finesse.model.Model.add`, which returns the
component added.

.. jupyter-execute::

    model = Model()
    l1 = model.add(Laser("l1", P=10))
    l1

Adding a component automatically creates an attribute on the
:class:`.finesse.model.Model` object with the name of the component.

.. jupyter-execute::

    model.l1

.. note::

    When writing a python script, your IDE might warn you that these attributes don"t
    exist and not provide autocompletion. When working in an interactive/Jupyter
    context, these attributes will be available for autocompletion after the ``add``
    method has been executed.

Component names need to be unique:

.. jupyter-execute::
    :raises:

    model = Model()
    model.add(Laser("l1", P=10))
    model.add(Laser("l1", P=10))

The :meth:`.finesse.model.Model.add` function also accepts an iterable of components:

.. jupyter-execute::

    model = Model()
    l1, l2, l3 = model.add([Laser(f"l{i}", P=i) for i in range(3)])
    model.components


Connecting components
=====================

For any useful simulation, components have to be connected together. Many
spaces must be made in more complicated models and often you do not need to give them
a name. Therefore the python interface provides multiple ways of doing so
depending on your use case.


Specifying ports on Space components
____________________________________

Directly adding a Space element is the most low-level option.
We first create and add the components for a simple cavity:

.. jupyter-execute::

    m = Model()

    l1, m1, m2 = m.add(
        [Laser("l1"),
         Mirror("m1", R=0.1, T=0.9),
         Mirror("m2", R=0.1, T=0.9)
        ]
    )

And then we create :class:`.finesse.components.space.Space` components, connecting their
:ref:`ports<ports>` to the :ref:`ports<ports>` of existing components.

.. jupyter-execute::

    s1 = m.add(Space("s1", portA=l1.p1, portB=m1.p1))
    s2 = m.add(Space("s2", portA=m1.p2, portB=m2.p1))

Using the connect method
________________________

The :meth:`.finesse.model.Model.connect` connects the provided components or ports
together and returns the created space/wire component. It tries to connect in a "smart"
way, so it can be useful to use the verbose argument to see what is happening.

.. jupyter-execute::

    m = Model()

    l1 = Laser("l1")
    m1 = Mirror("m1", R=0.1, T=0.9)
    m2 = Mirror("m2", R=0.1, T=0.9)

    m.add([l1, m1, m2])

    s1 = m.connect(l1, m1, L=1, name="s1", verbose=True)
    s2 = m.connect(m1, m2, L=1, name="s2", verbose=True)


Using the link method
_____________________

The :meth:`.finesse.model.Model.link` method calls the
:meth:`.finesse.model.Model.connect` method between each pair of components provided.
Connector names will be autogenerated, but it is possible to specify the length/time
delay of the connector by adding integers to the argument list. This is useful
when you have a long list of components to connect quickly.

.. jupyter-execute::

    m = Model()

    l1 = Laser("l1")
    m1 = Mirror("m1", R=0.1, T=0.9)
    m2 = Mirror("m2", R=0.1, T=0.9)
    # Connect with distances l1 - 10m -> m1 - 20m -> m2
    m.link(l1, 10, m1, 20, m2, verbose=True)

You can also be more verbose with the ports linked :code:`m.link(l1.p1, 10,
m1.p2, m2.p1, 20, m2.p2, verbose=True)`. Note that when connecting through a
component you need to specify which port to in and which to go out, as seen with
:code:`m1` above.

Using the chain method
______________________
This method is documented for completeness but maybe removed later as link and
connect above are used far more frequently.

The :meth:`.finesse.model.Model.chain` method is similar to the
:meth:`.finesse.model.Model.link` method. One difference is it accepts dictionaries that
specify space components, allowing for named connectors.

.. jupyter-execute::

    m = Model()
    l1, m1, m2 = m.chain(
        Laser("l1"), Mirror("m1"), {"name": "s1", "L": 1}, Mirror("m2")
    )
    print(m.s1)

.. _model_visualization:

Visualizing the model
=====================


After creating and adding your components, it can be helpful to visualize your model to
ensure your components are connected like you would expect. For this example we will
create a simple interferometer.

.. jupyter-execute::

    m = Model()

    l1 = Laser("l1")
    bs = Beamsplitter("bs", R=0.5, T=0.5)
    m.link(l1, bs)

    ETMx = Mirror("ETMx", R=1, T=0)
    m.link(bs.p3, ETMx)

    ETMy = Mirror("ETMy", R=1, T=0)
    m.link(bs.p2, ETMy)

    signal = PowerDetector("signal", m.bs.p4.o)
    m.add(signal)

Using component_tree
--------------------

We can use :meth:`.finesse.model.Model.component_tree` to draw a tree of the model using
ASCI characters.

.. jupyter-execute::

    print(m.component_tree())

For larger models, it can be clearer to only display a subsection of the model, by using
the ``root`` and ``radius`` arguments to select a subset of the graph.

.. jupyter-execute::

    # Only display components that are connect directly to the end mirror
    print(m.component_tree("ETMx", radius=1))

We can exchange some clarity with verbosity by showing the ports components are connected
to by using the ``show_ports`` argument.

.. jupyter-execute::

    print(m.component_tree(show_ports=True))

We can also include the detectors in the component tree, although they are strictly
speaking not components since they are not part of the optical network.

.. jupyter-execute::

    print(m.component_tree(show_detectors=True))

Finally we can also use ``component_tree`` to visualize other networks besides
the component network, using the ``network_type`` argument:

.. jupyter-execute::

    from finesse.utilities.network_filter import NetworkType

    # note you can also use 'network_type="optical"'
    print(m.component_tree(m.l1.p1.o, network_type=NetworkType.OPTICAL))


Using plot_graph
----------------

You can also directly visualize the :ref:`model_graph` by using :mod:`networkx` via
:meth:`.finesse.model.Model.plot_graph`.

.. jupyter-execute::

    m.plot_graph(graphviz=False)

To see more information about how the optical ports are connected, you can specify the
network type ``optical``.

.. jupyter-execute::

    m.plot_graph(network_type="optical", graphviz=False)

To get a prettier view, you can get use the optional pygraphviz dependency (which you
should have if you used :ref:`conda<installation-conda>`, otherwise see `here
<https://pygraphviz.github.io/documentation/stable/install.html>`__)

.. jupyter-execute::

    m.plot_graph(network_type="optical", graphviz=True)

Note that the ``graphviz`` argument controls whether graphviz will be used. If not
available, it will automatically revert to ``networkx`` and emit a warning.

``plot_graph`` also supports the ``radius`` and ``root`` arguments, which should be used
in tandem.

.. jupyter-execute::

    m.plot_graph(network_type="optical", graphviz=True, root="bs.p2.o", radius=2)


Component freezing and unfreezing
=================================

Freezing and unfreezing components is a way to prevent the user from adding new
attributes of a model element accidentally. This stops the user from making
commong typos, such as setting ``mirror.r`` instead of ``mirror.R``.
The :class:`~finesse.element.ModelElement` base class, which all components and
detectors inherit from, has a :meth:`~finesse.element.ModelElement._freeze` and
:meth:`~finesse.element.ModelElement._unfreeze` method.

If the user wants to store additional attributes for a component, they can
unfreeze it, set the attributes, and then freeze it again. This can be useful
for storing auxiliary information about the component, such as experimental
data, metadata, or other information that is not part of the model itself.

.. jupyter-execute::

    model = Model()
    l1 = model.add(Laser("l1", P=10))
    l1._unfreeze()
    l1.my_attr = "test"
    l1._freeze()
    print(l1.my_attr)

.. note::

    Elements are only frozen after they have been added to a model. Before that
    the elements are unfrozen and can be modified freely, which the user should
    be careful with.
